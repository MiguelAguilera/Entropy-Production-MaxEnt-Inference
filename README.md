# Inferring Entropy Production in Many-Body Systems Using Nonequilibrium MaxEnt

The repository contains code to generate data and estimate entropy production (EP) for high-dimensional systems. It accompanies the manuscript:

* Miguel Aguilera, Sosuke Ito, and Artemy Kolchinsky, "Inferring entropy production in many-body systems using nonequilibrium MaxEnt", 2025. [arXiv:2505.10444](https://arxiv.org/abs/2505.10444)

The code uses `numpy`, `numba`, and `torch` for acceleration (taking advantage of GPU if available). 

### Demonstration files

We include few simple scripts to get started.

**example_multipartite.py**: shows how to generate data and estimate EP in a multipartite dataset (the nonequilibrium spin model).

**example_general.py**: shows how to generate data and estimate EP in a general dataset (i.e., possibly nonmultipartite), where the trajectories are specified by samples of starting and ending states. (In this example script, the dataset is also generated by the nonequilibrium spin model, but converted to nonmultipartite format).

### Code files

See comments in files for more details.

* **ep_estimators.py**: functions to estimate EP from sampled data, including our estimator, the 1-step Newton-method approximation, and the multidimensional TUR.

* **spin_model.py**: implementation of the the nonequilibrium spin model, including generation of random coupling matrices, Monte Carlo sampling (`spin_model.run_simulation(...)`), and estimation of "ground-truth" EP from empirical statistics. In order to minimize memory/storage, `spin_model.run_simulation` returns samples in a compressed format that exploits the multipartite nature of the dynamics. Specifically, it returns a pair of numpy arrays `S` and `F` where:
    * `S` is a 2-dimensional array of type `int8` containing states sampled from the steady-state distribution. 
For a system with `N` spins, `S` has dimensions `[samples_per_spin] x [N]` and its entries are all -1s and 1s.
    * `F` is a 2-dimensional array of type `bool` also with dimensions `[samples_per_spin] x [N]`. `F` provides
a compressed representation of `samples_per_spin * N` samples of spin flips. 
Specifically, `F[j,i]=True` if spin `i` flipped in a random sample starting from state `S[j,:]`, 
and `F[j,i]=False` if it did not flip.
The set of states in which spin `i` flipped can be accessed as `S[F[:,i],:]`.

* **observables.py**: compute cross-correlation-type observables considered in our paper, $g_{ij}(\vec{\boldsymbol{x}}) =(x_{i,1}-x_{i,0})x_{j,0}$ and $g_{ij}(\vec{\boldsymbol{x}}) =x_{i,1}x_{j,0}-x_{i,0}x_{j,1}$

* **optimizers.py**: implementation of several optimizers, including gradient-based and Newton-based. By default, we use gradient ascent with Barzilai-Borwein step sizes.

* **linear_solvers.py**: code for solving linear systems, possibly with region constraints.

* **utils.py**: miscellaneous useful functions for working with `torch`, etc.

* **tests.py**: a few  unit tests. Can be run with `pytest tests.py` from the root directory.

The directories 
**results_spinmodel/** and **results_neuropixels/** contain additional code used to study the two examples discussed in the manuscript.
